--- dbus-1.10.18/bus/bus.c.orig	2017-06-06 18:43:23.000000000 +0900
+++ dbus-1.10.18/bus/bus.c	2017-06-06 18:47:16.000000000 +0900
@@ -753,12 +753,14 @@
   context = NULL;
   parser = NULL;
 
+	printf("aaa1\n");
   if (!dbus_server_allocate_data_slot (&server_data_slot))
     {
       BUS_SET_OOM (error);
       return NULL;
     }
 
+	printf("aaa2\n");
   context = dbus_new0 (BusContext, 1);
   if (context == NULL)
     {
@@ -767,15 +769,18 @@
     }
   context->refcount = 1;
 
+	printf("aaa3\n");
   if (!_dbus_generate_uuid (&context->uuid, error))
     goto failed;
 
+	printf("aaa4\n");
   if (!_dbus_string_copy_data (config_file, &context->config_file))
     {
       BUS_SET_OOM (error);
       goto failed;
     }
 
+	printf("aaa5\n");
   context->loop = _dbus_loop_new ();
   if (context->loop == NULL)
     {
@@ -783,6 +788,7 @@
       goto failed;
     }
 
+	printf("aaa6\n");
   context->watches_enabled = TRUE;
 
   context->registry = bus_registry_new (context);
@@ -792,6 +798,7 @@
       goto failed;
     }
 
+	printf("aaa7\n");
   parser = bus_config_load (config_file, TRUE, NULL, error);
   if (parser == NULL)
     {
@@ -799,11 +806,13 @@
       goto failed;
     }
 
+	printf("aaa8\n");
   if (!process_config_first_time_only (context, parser, address, flags, error))
     {
       _DBUS_ASSERT_ERROR_IS_SET (error);
       goto failed;
     }
+	printf("aaa9\n");
   if (!process_config_every_time (context, parser, FALSE, error))
     {
       _DBUS_ASSERT_ERROR_IS_SET (error);
@@ -813,6 +822,7 @@
   /* we need another ref of the server data slot for the context
    * to own
    */
+	printf("aaa10\n");
   if (!dbus_server_allocate_data_slot (&server_data_slot))
     _dbus_assert_not_reached ("second ref of server data slot failed");
 
@@ -821,12 +831,14 @@
    * other random thing. But I think the answer is "don't do
    * that then"
    */
+	printf("aaa11\n");
   if (print_addr_pipe != NULL && _dbus_pipe_is_valid (print_addr_pipe))
     {
       DBusString addr;
       const char *a = bus_context_get_address (context);
       int bytes;
 
+	printf("aaa12\n");
       _dbus_assert (a != NULL);
       if (!_dbus_string_init (&addr))
         {
@@ -834,6 +846,7 @@
           goto failed;
         }
 
+	printf("aaa13\n");
       if (!_dbus_string_append (&addr, a) ||
           !_dbus_string_append (&addr, "\n"))
         {
@@ -842,6 +855,7 @@
           goto failed;
         }
 
+	printf("aaa14\n");
       bytes = _dbus_string_get_length (&addr);
       if (_dbus_pipe_write (print_addr_pipe, &addr, 0, bytes, error) != bytes)
         {
@@ -855,12 +869,14 @@
           goto failed;
         }
 
+	printf("aaa15\n");
       if (!_dbus_pipe_is_stdout_or_stderr (print_addr_pipe))
         _dbus_pipe_close (print_addr_pipe, NULL);
 
       _dbus_string_free (&addr);
     }
 
+	printf("aaa16\n");
   context->connections = bus_connections_new (context);
   if (context->connections == NULL)
     {
@@ -868,6 +884,7 @@
       goto failed;
     }
 
+	printf("aaa17\n");
   context->matchmaker = bus_matchmaker_new ();
   if (context->matchmaker == NULL)
     {
@@ -875,6 +892,7 @@
       goto failed;
     }
 
+	printf("aaa18\n");
   /* check user before we fork */
   if (context->user != NULL)
     {
@@ -899,6 +917,7 @@
       {
         _dbus_verbose ("Forking and becoming daemon\n");
 
+	printf("aaa19\n");
         if (!_dbus_become_daemon (context->pidfile ? &u : NULL,
                                   print_pid_pipe,
                                   error,
@@ -916,6 +935,7 @@
          * not for the child process. This is a no-op if the pidfile
          * is NULL and print_pid_pipe is NULL.
          */
+	printf("aaa20\n");
         if (!_dbus_write_pid_to_file_and_pipe (context->pidfile ? &u : NULL,
                                                print_pid_pipe,
                                                _dbus_getpid (),
@@ -927,6 +947,7 @@
       }
   }
 
+	printf("aaa21\n");
   if (print_pid_pipe && _dbus_pipe_is_valid (print_pid_pipe) &&
       !_dbus_pipe_is_stdout_or_stderr (print_pid_pipe))
     _dbus_pipe_close (print_pid_pipe, NULL);
@@ -938,6 +959,7 @@
    * when the main thread calls setuid().
    * https://bugs.freedesktop.org/show_bug.cgi?id=92832
    */
+	printf("aaa22\n");
   if (context->user != NULL)
     {
       if (!_dbus_change_to_daemon_user (context->user, error))
@@ -950,8 +972,10 @@
   /* Auditing should be initialized before LSMs, so that the LSMs are able
    * to log audit-events that happen during their initialization.
    */
+	printf("aaa23\n");
   bus_audit_init (context);
 
+	printf("aaa24\n");
   if (!bus_selinux_full_init ())
     {
       bus_context_log (context, DBUS_SYSTEM_LOG_FATAL, "SELinux enabled but D-Bus initialization failed; check system log\n");
@@ -976,19 +1000,23 @@
    * to process <associate/> elements.
    * http://lists.freedesktop.org/archives/dbus/2008-October/010491.html
    */
+	printf("aaa25\n");
   if (!process_config_postinit (context, parser, error))
     {
       _DBUS_ASSERT_ERROR_IS_SET (error);
       goto failed;
     }
 
+	printf("aaa26\n");
   if (parser != NULL)
     {
       bus_config_parser_unref (parser);
       parser = NULL;
     }
 
+	printf("aaa27\n");
   dbus_server_free_data_slot (&server_data_slot);
+	printf("aaa28\n");
 
   return context;
 
